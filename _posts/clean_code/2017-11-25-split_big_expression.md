---
layout: post
title: 거대한 표현을 잘게 쪼개기
published: True
categories: 
- clean_code
tags:
- 클린코드
- 읽기 좋은 코드가 좋은 코드다
---



## Chapter 8. 거대한 표현을 잘게 쪼개기

* 사람은 한번에 서너개의 '일'만 기억할 수 있다.
* 따라서, 코드를 작성할 때에도, 커다란 덩어리보다는 잘게 쪼개서 표현해야 한다.
* 커다란 덩어리를 잘게 쪼개서 표현하는 방법은 여러가지가 있다.





### 설명변수

* 앞서 말한 커다란 덩어리를 잘게 쪼개는 가장 간단한 방법 중 하나가 **설명변수**이다.
* 다음과 같은 코드가 있다고 치자.
  * 어떤 라인을 ':'로 분리하고 0번째를 선택하고 공백을 제거한 것이 "root"라는 문자열과 같으냐.
  * 조건문을 읽는데 매우 많은 일들이 **한번에** 일어나고 있다.
  * 또한, line을 ':'로 나누고 0번째에 있는 값의 공백을 제거한 것이 **어떤 것을 가리키는지도 모른다.**

```java
if (line.split(':')[0].strip() == "root") {
  ...
}
```



* 위의 코드를 다음과 같이 **설명 변수**를 통해 수정해본다.
* 이제는 line을 ':'로 나누고 0번째에 있는 값의 공백을 제거한 것이 **어떤 것인지 알겠다.**
* userName이 루트냐.
* 훨씬 더 읽기 편해진거 같다. ㅇㅈ? ㅇ ㅇㅈ.

```java
String userName = line.split(':')[0].strip();
if(userName == "root") {
  ...
}
```



### 요약변수

* 이번에는 요약변수이다.
* 말그대로 커다란 덩어리의 표현을 짧게 요약해줄 수 있는 변수에 담는 것이다.
* 다음 예시를 보자.
* 뭐 이런 예시가 있다고 치자. 요청자의 아이디가 어떤 문서의 주인이냐를 묻고있다.
* 내가보기에 사실 이정도는 괜찮은 것 같다. 하지만 분명 다소 복잡한 조건문을 작성해야 할 때가 있을 것이다. 이 예시는 그냥 간단한 예시다.

```java
if (request.userId == document.ownerId) {
  ...
}
```



* 위의 코드를 **요약변수**를 통해 수정해본다.
* 다음과 같이 수정하면, isDocumentOwner만 보고 '아, 어떤 문서의 주인인지를 확인하는구나'하고 빠르게 이해하고 넘어갈 수 있다.

```
boolean isDocumentOwner = (request.userId == document.ownerId);
if (isDocumentOwner) {
  ...
}
```



### 드모르간의 법칙

* 드모르간의 법칙을 이용하면 조건문을 조금 더 설명하고자 하는 방향으로 수정할 수 있다.
* 다음 코드를 해석해보자. **''파일이 존재하는데 보호받지않는 파일의 부정형''**. 욕나온다.

```
if (!(isExistsFile && !isProtectedFile)) {
  ...
}
```



* 다시 해석해보면 **"파일이 존재하지 않거나, 보호상태인 파일"**이다. 드모르간의 법칙이 이것이다.
* 부정형을 분배하고 and/or을 바꿔라
* 이게 조금 더 읽기 편하다. 조건문에 부정형을 가능한 피하자는 이유도 여기에 있는 것 같다.
  * 조건문 전체의 부정형을 말하는 것.

```java
if (!isExistsFile && isProtectedFile) {
  ...
}
```



### 쇼트 서킷 논리 오용말기

* 다중 조건문을 보면, 앞의 조건에 결과에 따라 뒤의 조건을 수행하지 않을 수도 있다.
* 예를 들어, `if (a || b)`에서 a가 참이면 b는 평가하지 않는다.
* 그런데, 위의 a, b 두 가지의 조건을 쇼트 서킷 논리를 통해 한 줄의 코드로 처리한 것이 좋은 방향인지는 생각해봐야한다.
* 코드를 읽는 사람이 그 쇼트 서킷 논리를 이해하는데 시간이 걸리기 때문이다. 간단하고 깔끔하다면야 문제가 되지 않지만, 그렇지 않은 경우에는 읽는 사람이 힘들 수 있다.
* 따라서, 쇼트 서킷 논리에 대해 자신이 짠 코드가 ''영리하게 잘 짰다''라고 생각하기 전에, 다른 사람이 보아도 이해하기 쉬운지를 먼저 생각해야한다.





### 복잡한 논리에 대해 우아하게 접근하기

* 가끔 복잡한 논리를 구현해야할 때가 있다.
* 예를 들어, 어떤 숫자 범위를 나타내는 구간들이 있고, 새로 삽입 될 구간이 다른 구간들을 모두 겹치는지 알고 싶다. 그런데 시작점은 포함하고 끝점은 포함하지 않는 조건이 있다.
* 그러려면, 시작점은 다른 시작점들보다 크거나 같고 다른 끝점들보다 작아야한다.
* 그리고 끝점은 다른 시작점들보다 크고 다른 끝점들보다 작거나 같아야한다.
* 마지막으로, 시작점은 다른 시작점들보다 작거나 같고, 끝점은 다른 끝점들보다 크거나 같은 경우를 검사해야한다.

```java
if (begin >= other.begin && begin < other.end || 
    end > orther.begin && end <= other.end || 
    begin <= other.begin && end >= other.end);
```



* 위의 조건은 순차적으로 차근차근 생각해서 적어본 조건들이다. 반대로 생각해보자. 반대는 겹치지 않는 것이다.
* 다른 범위들의 끝점이 시작점보다 작거나 같냐. 다른 범위의 끝점들이 시작점보다 작냐이다.
* 앞에서 반대되는 조건들만 잘라주면 된다. 더 이해하기 쉬운 것을 볼 수 있다.

```java
if (begin >= other.end) {
  return false;
}

if (end <= other.begin) {
  return false;
}

...
```



* 이처럼 복잡한 논리의 경우 한번쯤은 반대되는 방법을 생각하여,  우아하게 처리할 수 있도록 노력해야한다.

